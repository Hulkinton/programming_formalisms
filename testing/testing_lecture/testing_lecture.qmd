---
title: "Testing"
author: "Richèl Bilderbeek"
format: revealjs
editor: visual
from: markdown+emoji
bibliography: testing_lecture.bib
csl: vancouver.csl
---

## Testing ![](CC-BY-NC-SA.png)

![](programming_formalism_course.png)

## Problems

When do you trust your code? 

. . .

When do you trust code written by others? 

. . .

How do you convince other developers of a bug?

## Testing

 * Coding errors are extremely common @baggerly2009deriving
 * Contribute to the reproducibility crisis in science @vable2021code, e.g. @rahman2020exploratory

Testing *helps* ensure the correctness of code.

![](beck_tdd_by_example.jpg) ![](langr_tdd.jpg) ![](thomas_and_hunt_the_pragmatic_programmer.jpg)

## Testing framework

 * **`unittest`**, `pytest`, `nose`, etc.
 * Makes it easier to write unit tests
 * Takes some scaffolding
 * Failed tests give a better error message

## Test if something is true

No testing framework:

```{python}
#| echo: true
#| eval: true
assert 1 + 1 == 2
```

Using `unittest`:

```{python}
#| echo: true
#| eval: true
import unittest

class TestSmall(unittest.TestCase):
    def test_is_true(self):
        self.assertIsTrue(1 + 1 == 2)
```

:neutral_face: Mostly scaffolding here

## Test if something is equal

No testing framework:

```{python}
#| echo: true
#| eval: true
assert 1 + 1 == 2
```

Using `unittest`:

```{python}
#| echo: true
#| eval: true
import unittest

class TestSmall(unittest.TestCase):
    def test_is_equal(self):
        self.assertEqual(1 + 1, 2)
```

:monocle_face: Hamcrest notation can give better error message.

## Test if something raises an exception

No testing framework:

```{python}
#| echo: true
#| eval: true
def raise_error():
    raise RunType("Raise an error!")

has_raised = False
try:
    raise_error() 
except:
    has_raised = True
assert has_raised
```

Using `unittest`:

```{python}
#| echo: true
#| eval: true
import unittest

class TestSmall(unittest.TestCase):
    def test_raises(self):
        self.assertRaises(RunTimeError, raise_error)
```

:smile: here it pays off.

## First example: `is_prime`

 * Function name: `is_prime`
 * Output:
   * Returns `True` if the input is prime
   * Returns `False` if the input is not prime
   * :warning: Gives an error when the input is not an integer
 * Work within scaffolding of [https://github.com/richelbilderbeek/programming_formalisms_testing](https://github.com/richelbilderbeek/programming_formalisms_testing)

## Live demo (15 minutes)

 * Or videos: [YouTube](https://youtu.be/qVtHieuwM1M) [download (.ogv)](https://richelbilderbeek.nl/tdd_python_is_prime.ogv)
 
## Exercise: `is_prime`, form

 * Pair up
 * Switch roles every 3 minutes
 * Discuss how to keep the time first
 * Person with GitHub username first in alphabet starts
 * Work on `master` branch only, share code using `git push` and `git pull`
 * Try to be **an exemplary duo** 

## Exercise: `is_prime`, technical

 * Create a Fork of [https://github.com/richelbilderbeek/programming_formalisms_testing](https://github.com/richelbilderbeek/programming_formalisms_testing)
 * Develop a function called `is_prime`:
   * `src/pftesting_richelbilderbeek/testing_questions.py` (has more questions)
   * `tests/test_testing_questions.py`
 * Modify `README.md`: replace `richelbilderbeek` by your own username
 * Extra: make all tests pass

## Break 1

Break!

## Problem

Q: What is the hardest in programming?

. . .

A: to work with people?

## Problem

How to work together well?

. . .

Encourage/enforce:

 * URL links are valid
 * Correct spelling
 * Code must pass all tests
 * High code coverage
 * Uniform coding style

## Continuous Integration

Scripts that are triggered when `push`ing code.

Assures quality:

 * Code has consistent style
 * Links are valid (i.e. not broken)
 * Spelling is correct
 * Tests pass
 * \[your check here\]

## Continuous Integration

 * CI significantly increase the number of bugs exposed @vasilescu2015
 * CI increases the speed at which new features are added @vasilescu2015

## Code coverage

 * Percentage of code tested
 * Correlates with code quality @horgan1994 @del1995correlation
 * 100% mandatory to pass a code peer-review by rOpenSci @ram2018community

## Coding style

 * Following a consistent coding style improves software quality @fang2001
     * Python: PEP8 @van2001pep
     * R: Tidyverse @wickham2019advanced
 * May include cyclomatic complexity
     * More complex code, more bugs @abd2018calculating @chen2019empirical @zimmermann2008predicting

## Coding style tools

 * Linter: program that tests code for style.

In Python: `ruff`, Sonar, `pytype`, Black, Codacy, Pylint, Flake8, `autopep8`, Pychecker, Pylama

## Disable a `ruff` test

```{python}
import random
random.randint(0, 1) # noqa: S311
```

You will need to defend this in a code review.

## Exercise: `get_digits`, form

 * Pair up again
 * Switch roles every 3 minutes
 * Discuss how to keep the time first
 * Person with GitHub username first in alphabet starts
 * Work on `master` branch only, share code using `git push` and `git pull`
 * Try to be **an exemplary duo** 

## Exercise: `get_digits`, technical

 * Create a Fork of [https://github.com/richelbilderbeek/programming_formalisms_testing](https://github.com/richelbilderbeek/programming_formalisms_testing)
 * Modify `README.md`: replace `richelbilderbeek` by your own username
 * Develop a function called `get_digits`:
   * `src/pftesting_richelbilderbeek/testing_questions.py` (has more questions)
   * `tests/test_testing_questions.py`
 * **Get all CI scripts to pass**

## Solutions

`get_digits` video:

 * [download (.ogv)](https://richelbilderbeek.nl/tdd_python_get_digits.ogv)
 * [YouTube](https://youtu.be/qVtHieuwM1M)

## Untestable functions

Q: How to test this function?

```{python}
def print_hello():
    print("Hello world")
```

. . .

A: Never write untestable functions

## Making untestable functions testable

Q: How to make this function testable?

```{python}
def print_hello():
    print("Hello world")
```

. . .

```{python}
def get_hello_world_text():
    return "Hello world"
```

## Testing indeterministic functions

Functions that do not always return the same values.

```{python}
#| echo: true
#| eval: true
def flip_coin():
    """Produce a random boolean."""
    return random.randint(0, 1) > 0
```

How to test these?

## Testing graphical functions

Q: How to test this function throroughly:
 * Plot looks pretty
 * Colors are correct
 * Trendline is drawn

```{python}
def save_plot(filename, x_y_data):
    """Save the X-Y data as a scatter plot"""
```

. . .

A: usually: use **a human**, e.g. a code reviewer

In most cases, graphical analysis tools and/or AI are overkill.
If you are stubborn: try!

## Randomness

A Random Number Generator ('RNG') produces the same random values after setting the same RNG seed.

```{python}
#| echo: true
#| eval: true
import random
random.seed(5)
assert flip_coin()
random.seed(2)
assert not flip_coin()
```

## Exercise: `flip_coin``, form

 * Pair up again
 * Switch roles every 3 minutes
 * Discuss how to keep the time first
 * Person with GitHub username first in alphabet starts
 * Work on `master` branch only, share code using `git push` and `git pull`
 * Try to be **an exemplary duo** 

## Exercise: `flip_coin`, technical

 * Create a Fork of [https://github.com/richelbilderbeek/programming_formalisms_testing](https://github.com/richelbilderbeek/programming_formalisms_testing)
 * Modify `README.md`: replace `richelbilderbeek` by your own username
 * Develop a function called `flip_coin`:
   * `src/pftesting_richelbilderbeek/testing_questions.py` (has more questions)
   * `tests/test_testing_questions.py`
 * **Get all CI scripts to pass**

## Break 2

> If all tests pass, we are -by definition- happy.
>
> Programming team [tresinformal](https://github.com/tresinformal)

Break 2

## Problem

Q: When one works in a team, how to make sure my code keeps doing the same?

```{python}
#| echo: true
#| eval: true
def get_test_dna_sequence():
  """Get a DNA sequence to be used in testing"""
  return "ACGTACGT"
```

. . .

A: Apply the Beyoncé Rule

## Beyoncé rule

'If you like it, then you gotta put a test on it'

```{python}
#| echo: true
#| eval: true
assert get_test_dna_sequence() == "ACGTACGT"
```

Teams should be reluctant to change tests: this will likely break other code.

![Beyoncé](beyonce.png)

> Source: [Wikimedia](https://commons.wikimedia.org/wiki/Category:Beyonc%C3%A9_Knowles_in_2020#/media/File:Beyonc%C3%A9_Black_Is_King_Still.png)

## Problem

Q: how to counter 'bit rot' @steele1983hacker or 'software collapse' @hinsen2019dealing

(we know: impossible to counteract @benureau2018re)

...

A: 

 * Xtreme programming: 'embrace change' @beck2000extreme
 * Add a scheduled monthly test on your CI script

## Consider static type checking

 * Use static type checking, see [PEP 484](https://peps.python.org/pep-0484/)

```
def reverse_string(s: str) -\> str: return s.reverse()
```

## Recap

 * Testing helps code correctness
   * Use the Beyoncé Rule on precious behavior
 * Continuous Integration helps work together
   * Use scheduled CI against bit rot

## Problems

 * We developed only simple algorithms
 * We only use simple data structures
 * We ignore if code is fast [*]

 * [*] vague wording on purpose

## Finally

Time for a Reflection!

Afterwards, you can rest or ask your final questions.

## The End

[The End]

## Links

 * [Former lecture on testing](https://uppmax.github.io/programming_formalism-automated_testing/)
 * [Hypermodern Python Cookiecutter](https://cookiecutter-hypermodern-python.readthedocs.io/en/2022.6.3.post1/)
 * [Scikit-HEP project info for developers](https://scikit-hep.org/developer)
