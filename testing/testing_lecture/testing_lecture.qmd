---
title: "Testing"
author: "Richèl Bilderbeek"
format: revealjs
editor: visual
from: markdown+emoji
bibliography: testing_lecture.bib
csl: vancouver.csl
---

## Testing

![](programming_formalism_course.png)

## Problem

When do you trust your code? When do you trust code written by others? How do you convince other developers of a bug?

## Testing 

 * Coding errors are extremely common @baggerly2009deriving
 * Contribute to the reproducibility crisis in science @vable2021code, 
   e.g. @rahman2020exploratory

Testing *helps* ensure the correctness of code.

![](beck_tdd_by_example.jpg) ![](langr_tdd.jpg) ![](thomas_and_hunt_the_pragmatic_programmer.jpg)

## Testing framework

-   **`unittest`**, `pytest`, `nose`, etc.
-   Makes it easier to write unit tests
-   Takes some scaffolding
-   Failed tests give a better error message.

## Test if something is true

```{python}
#| echo: true
#| eval: true
assert 1 + 1 == 2
```

```{python}
#| echo: true
#| eval: true
import unittest

class TestSmall(unittest.TestCase):
    def test_is_true(self):
        self.assertIsTrue(1 + 1 == 2)
```

:neutral_face: Mostly scaffolding here

## Test if something is equal

```{python}
#| echo: true
#| eval: true
assert 1 + 1 == 2
```

```{python}
#| echo: true
#| eval: true
import unittest

class TestSmall(unittest.TestCase):
    def test_is_equal(self):
        self.assertEqual(1 + 1, 2)
```

:monocle_face: Hamcrest notation can give better error message.

## Test if something raises an exception

```{python}
#| echo: true
#| eval: true
def raise_error():
    raise RunType("Raise an error!")

has_raised = False
try:
    raise_error() 
except:
    has_raised = True
assert has_raised
```

```{python}
#| echo: true
#| eval: true
import unittest

class TestSmall(unittest.TestCase):
    def test_raises(self):
        self.assertRaises(RunTimeError, raise_error)
```

:smile: here it pays off.

## First example: `is_prime`

-   Function name: `is_prime`
-   Output:
    -   Returns `True` if the input is prime
    -   Returns `False` if the input is not prime
    -   :warning: Gives an error when the input is not an integer
-   Work within scaffolding of <https://github.com/richelbilderbeek/programming_formalisms_medium_project>

## Live demo (15 minutes)

<https://youtu.be/qVtHieuwM1M>

-   (or [download (.ogv)](https://richelbilderbeek.nl/tdd_python_is_prime.ogv))

## Exercise

-   Pair up
-   Switch roles every 3 minutes
-   Discuss how to keep the time first
-   Person with GitHub username first in alphabet starts
-   Create a Fork of <https://github.com/richelbilderbeek/programming_formalisms_testing>
-   Develop a function called `get_digits`
-   Try to be **exemplary**
-   We'll discuss a repo history after the break

Instructors will visit the rooms to observe.

Done? Try [more easy prime functions](https://github.com/UPPMAX/programming_formalisms/blob/main/learning_line.md#prime-easy)

## Break 1

Break!

`get_digits` video:

-   [download (.ogv)](https://richelbilderbeek.nl/tdd_python_get_digits.ogv)
-   [YouTube](https://youtu.be/qVtHieuwM1M)

## Problem

How to work together well?

. . .

Encourage/enforce:

-   URL links are valid
-   Correct spelling
-   Code must pass all tests
-   High code coverage
-   Uniform coding style

## Continuous Integration

Scripts that are triggered when `push`ing code.

Assures quality:

-   Code has consistent style
-   Links are valid (i.e. not broken)
-   Spelling is correct
-   Tests pass
-   \[your check here\]

## Continuous Integration

 * CI significantly increase the number of bugs exposed @vasilescu2015
 * CI increases the speed at which new features are added @vasilescu2015

## Code coverage

 * Percentage of code tested
 * Correlates with code quality @horgan1994 @del1995correlation
 * 100% mandatory to pass a code peer-review by rOpenSci @ram2018community

## References


## Coding style

 * Following a consistent coding style improves software quality @fang2001
   * Python: PEP8 @van2001pep
   * R: Tidyverse @wickham2019advanced
 * May include cyclomatic complexity
   * More complex code, more bugs @abd2018calculating @chen2019empirical @zimmermann2008predicting

## Coding style tools

 * Linter: program that tests code for style.

In Python: `ruff`, Sonar, `pytype`, Black, Codacy, Pylint, Flake8, `autopep8`, Pychecker, Pylama

 
## Testing indeterministic functions

Functions that do not always return the same values.

```{python}
#| echo: true
#| eval: true
def flip_coin():
    """Produce a random boolean."""
    return random.randint(0, 1) > 0
```

How to test these?

## Randomness

A Random Number Generator ('RNG') produces the same random values after setting the same RNG seed.

```{python}
#| echo: true
#| eval: true
import random
random.seed(5)
assert flip_coin()
random.seed(2)
assert not flip_coin()
```

## Problem

Q: When one works in a team, how to make sure my code keeps doing the same?

```{python}
#| echo: true
#| eval: true
def get_test_dna_sequence():
  """Get a DNA sequence to be used in testing"""
  return "ACGTACGT"
```

. . .

A: The Beyoncé Rule

## Beyoncé rule

'If you like it, then you gotta put a test on it'

```{python}
#| echo: true
#| eval: true
assert get_test_dna_sequence() == "ACGTACGT"
```

![Beyoncé](beyonce.png)

> Source: [Wikimedia](https://commons.wikimedia.org/wiki/Category:Beyonc%C3%A9_Knowles_in_2020#/media/File:Beyonc%C3%A9_Black_Is_King_Still.png)

## Exercise

## Break 2

Break 2

## Theory: software degradation

 * Software degrades
 * 'bit rot' [1] or 'software collapse' [2]

Solution:

 * Xtreme programming: 'embrace change' [3]
 * Add a scheduled monthly test on your CI script

## References

 * [1] Steele Jr, Guy L., et al. The hacker's dictionary: a guide to the world of computer wizards. Harper & Row Publishers, Inc., 1983.
 * [2] Hinsen, Konrad. "Dealing with software collapse." Computing in Science & Engineering 21.3 (2019): 104-108.
 * [3] Beck, Kent. Extreme programming explained: embrace change. addison-wesley professional, 2000.
 
## Recap


## End

## Extra

### Static type-checking with mypy

Python is an interpreted language, however, as of PEP 484 it supports Type Hints. Some very popular packages like pydantic even use type hints to evaluate input at runtime.

```         
type_checking.py

def reverse_string(s: str) -\> str: return s.reverse()
```

We can now evaluate if there are any type errors using mypy.

```         
mypy type_checking.py
```

Benefits of Type Hints

-   Improves readability (I think)
-   Easier to spot bugs and maintain project
-   Forces you to think
-   Better autocomplete if using language server

### Where to go from here

If you are interested in learning more tools and ways to improve the quality of your project, a really good place to start is looking at cookie cutter templates. Two great ones for Python are:

```         
https://cookiecutter-hypermodern-python.readthedocs.io/en/2022.6.3.post1/
https://scikit-hep.org/developer
```

## Links

-   [Former lecture on testing](https://uppmax.github.io/programming_formalism-automated_testing/)
